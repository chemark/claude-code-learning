# 🧹 /clear 命令完整学习指南

> 管理对话上下文，保持高效清晰的工作状态

## 📋 目录

- [基础概念](#基础概念)
- [快速开始](#快速开始)
- [基本用法](#基本用法)
- [高级功能](#高级功能)
- [实战场景](#实战场景)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)
- [技巧和窍门](#技巧和窍门)

---

## 基础概念

### 什么是 /clear 命令？

`/clear` 命令用于清除当前的对话上下文，开始一个全新的会话。

**它会清除**：
- ✅ 当前对话的所有消息
- ✅ 临时的上下文信息
- ✅ 中间状态和变量
- ✅ 未完成的任务

**它不会清除**：
- ❌ 命令历史（仍可通过 ↑ 访问）
- ❌ Claude 的记忆（通过 # 或 /memory 添加的）
- ❌ 文件系统的更改
- ❌ Git 提交历史

### 为什么需要 /clear？

**场景 1: 对话太长**
```
问题：
- 对话包含几百条消息
- Claude 响应变慢
- 上下文混乱

解决：
/clear  # 清除历史，提升性能
```

**场景 2: 切换任务**
```
问题：
- 刚完成功能 A
- 要开始功能 B
- 但 Claude 还记着 A 的上下文

解决：
/clear  # 清除上下文，专注新任务
```

**场景 3: 上下文污染**
```
问题：
- 之前的错误讨论
- 误导性的信息
- 过时的假设

解决：
/clear  # 清除干扰，重新开始
```

### /clear vs /exit

| 操作 | /clear | /exit |
|------|--------|-------|
| 清除对话 | ✅ | ✅ |
| 保持会话 | ✅ | ❌ |
| 退出程序 | ❌ | ✅ |
| 保留记忆 | ✅ | ✅ |
| 保留历史 | ✅ | ✅ |

**简单说**：
- `/clear` = 清除对话，继续工作
- `/exit` = 保存并退出程序

---

## 快速开始

### 30 秒快速体验

```bash
# 1. 开始一些对话
"创建一个 React 组件"
"添加一些功能"
"再修改一下"

# 2. 现在对话很长了，清除它
/clear

# 3. 现在是全新的开始
"开始新任务"  # Claude 不记得之前的组件
```

### 第一次使用

**理解清除的效果**：

```bash
# Before /clear
你: "我在开发一个博客系统"
Claude: "明白，博客系统..."

你: "添加评论功能"
Claude: "为你的博客系统添加评论..."  # 记得之前的上下文

# 执行清除
/clear

# After /clear
你: "添加评论功能"
Claude: "你想为什么项目添加评论？"  # 不记得博客系统了
```

**何时清除**：
```bash
✅ 任务完成，开始新任务
✅ 对话太长，影响性能
✅ 上下文混乱，需要重新开始
✅ 切换到完全不同的项目

❌ 任务进行中
❌ 需要保留上下文信息
❌ 多步骤任务未完成
```

---

## 基本用法

### 1. 简单清除

```bash
# 方式 1: 使用命令（推荐）
/clear

# 方式 2: 自然语言
"清除对话"
"清空上下文"
"重新开始"
```

**执行效果**：
```
┌─────────────────────────────────────┐
│ ✓ Conversation cleared              │
│                                     │
│ Starting fresh conversation.        │
│ Memory and command history retained.│
└─────────────────────────────────────┘
```

### 2. 清除前的确认

**自动确认**：
```bash
# 直接清除，无需确认
/clear
```

**如果想要确认提示**：
```bash
# 创建自定义命令 .claude/commands/safe-clear.md
你确定要清除当前对话吗？

当前对话包含 X 条消息。

清除后将：
✓ 删除所有对话历史
✓ 清除临时上下文
✓ 保留 Claude 记忆
✓ 保留命令历史

是否继续？[y/N]
```

### 3. 清除后的最佳开场

```bash
# ❌ 不好的开场
/clear
"继续之前的工作"  # Claude 不知道之前做什么

# ✅ 好的开场
/clear
"我要开发用户认证功能
使用 Express + JWT
项目结构是 MVC 模式"  # 提供新的清晰上下文
```

---

## 高级功能

### 1. 选择性保留信息

虽然 `/clear` 会清除对话，但你可以在清除后立即提供关键信息：

```bash
# 清除前总结关键点
"总结我们刚才讨论的要点"

# Claude 给出总结...

# 复制总结内容

# 清除对话
/clear

# 粘贴总结，继续工作
"基于以下背景继续：
[粘贴总结内容]

现在开始新任务..."
```

### 2. 配合记忆系统

**方法 1: 清除前保存到记忆**
```bash
# 如果有重要的项目信息
#
"记住以下项目配置：
- 使用 React + TypeScript
- 组件放在 src/components
- 使用 Tailwind CSS
- API 路径: /api/v1"

# 清除对话
/clear

# 记忆中的信息仍然保留
"创建一个新组件"  # Claude 仍知道项目配置
```

**方法 2: 清除后恢复上下文**
```bash
/clear

# 快速恢复项目上下文
"这是一个 [项目类型] 项目
我刚完成了 [功能 A]
现在要开始 [功能 B]"
```

### 3. 定时清除策略

创建自定义命令实现定时清除提醒：

```bash
# .claude/commands/check-clear.md

检查对话长度：
- 如果对话超过 50 条消息，建议清除
- 如果超过 30 分钟，建议清除
- 如果切换主题，建议清除

是否现在清除？
```

### 4. 与其他命令配合

**清除 + 恢复会话**：
```bash
# 保存当前会话
# （会话会自动保存）

# 清除对话
/clear

# 稍后恢复
/resume  # 选择之前的会话
```

**清除 + 查看记忆**：
```bash
/clear

# 确认重要信息还在
/memory

# 看到保存的偏好和配置
# 继续工作
```

---

## 实战场景

### 场景 1: 切换项目

**情况**：从项目 A 切换到项目 B

```bash
# 在项目 A 中工作
"优化数据库查询"
"添加缓存层"
# ... 很多对话 ...

# 完成项目 A，准备切换

# 1. 总结并提交
"总结今天的工作"
git commit -am "完成数据库优化"

# 2. 清除上下文
/clear

# 3. 切换项目
cd ../project-b

# 4. 开始项目 B，提供新上下文
"现在在项目 B
这是一个 Vue 3 前端项目
要添加暗色模式功能"
```

### 场景 2: 调试陷入困境

**情况**：尝试了很多方案，对话很乱

```bash
# 尝试了多次
"这个 bug 怎么修？"
"试试方案 A"  # 失败
"试试方案 B"  # 失败
"再试试 C"    # 还是失败
# ... 对话充满了失败的尝试 ...

# 上下文已经很混乱
# 决定重新开始

# 1. 记录失败的方案
"总结我们尝试的所有方案及为什么失败"
# 复制输出到笔记

# 2. 清除混乱的上下文
/clear

# 3. 重新描述问题
"遇到以下 bug：
[清晰描述问题]

错误信息：
[粘贴错误]

已尝试的方案：
- 方案 A: 失败原因...
- 方案 B: 失败原因...

请提供新的思路"
```

### 场景 3: 性能优化

**情况**：对话太长，Claude 响应变慢

```bash
# 注意到响应变慢
# 检查原因

"我们这次对话有多少条消息？"
# Claude: "大约 150 条消息"

# 决定清理

# 1. 保存重要信息
"总结我们讨论的核心要点"
# 保存输出

# 2. 清除提升性能
/clear

# 3. 恢复必要上下文
"基于以下要点继续：
[粘贴核心要点]"

# 现在响应快多了
```

### 场景 4: 每日工作流

**情况**：每天开始新的工作

```bash
# 早上开始工作

# 1. 查看昨天的会话（可选）
/resume  # 回顾昨天做了什么

# 2. 清除昨天的上下文
/clear

# 3. 开始今天的工作
"今天的任务：
1. 修复 bug #123
2. 添加用户头像功能
3. 更新文档

当前进度：
- bug #123 已定位
- 设计稿已确认"
```

---

## 最佳实践

### 1. 何时清除

**✅ 应该清除的时机**：
```bash
# 任务完成
完成功能 → git commit → /clear → 新任务

# 切换上下文
项目 A → /clear → 项目 B

# 对话过长
> 100 条消息 → /clear

# 上下文混乱
多次失败尝试 → /clear → 重新开始

# 每日开始
新的一天 → /clear → 新的任务
```

**❌ 不应该清除的时机**：
```bash
# 任务进行中
正在调试 → ❌ 不要清除

# 多步骤操作
步骤 2/5 → ❌ 不要清除

# 等待输出
Claude 正在生成 → ❌ 不要清除

# 需要上下文
依赖之前讨论 → ❌ 不要清除
```

### 2. 清除前的准备

**✅ 清除前检查清单**：
```markdown
- [ ] 当前任务已完成
- [ ] 重要信息已保存
- [ ] 代码已提交
- [ ] 没有未完成的操作
- [ ] 确认要开始新任务
```

**✅ 保存重要信息**：
```bash
# 方法 1: 总结到文件
"总结今天的工作和决策" > NOTES.md

# 方法 2: 保存到记忆
#
"记住项目的关键配置"

# 方法 3: Git 提交
git commit -am "完成功能 X"
```

### 3. 清除后的恢复

**✅ 提供清晰的新上下文**：
```bash
/clear

# 好的开场
"我在开发电商项目
技术栈：Next.js + PostgreSQL
当前任务：实现购物车功能
已完成：商品列表、详情页"

# 不好的开场
"继续"  # Claude 不知道继续什么
```

**✅ 利用项目文件**：
```bash
/clear

"阅读 README.md 了解项目
阅读 docs/ARCHITECTURE.md 了解架构
现在开始实现支付功能"
```

### 4. 清除频率

**推荐频率**：
```bash
# 按时间
每天开始 → /clear
每 2-3 小时 → 考虑清除

# 按对话长度
50+ 消息 → 考虑清除
100+ 消息 → 建议清除
200+ 消息 → 必须清除

# 按任务
每个大任务完成 → /clear
切换项目 → /clear
```

### 5. 与团队协作

**团队规范示例**：
```markdown
## Claude Code 使用规范

### 清除规范
1. **每日开始**: 执行 /clear
2. **任务切换**: 必须 /clear
3. **提交代码前**: 总结 + /clear
4. **休息回来**: /clear + 回顾

### 上下文管理
1. 重要决策记录到 docs/decisions/
2. 项目配置保存到 Claude 记忆
3. 定期导出对话记录
```

---

## 常见问题

### Q1: /clear 会删除我的代码吗？

**回答**：不会！

```bash
/clear 只清除对话历史
你的文件、代码、Git 历史完全不受影响

清除的是：
✓ 对话消息
✓ 临时上下文

不清除的是：
✓ 文件系统
✓ Git 历史
✓ Claude 记忆
✓ 命令历史
```

### Q2: 清除后如何恢复之前的对话？

**方法 1: 使用 /resume**
```bash
/clear      # 清除当前

# 稍后想看之前的对话
/resume     # 选择之前的会话
```

**方法 2: 查看命令历史**
```bash
# 清除后仍可访问命令
↑ ↑ ↑      # 浏览之前的命令
Ctrl+R      # 搜索历史命令
```

**方法 3: 导出对话记录**
```bash
# 清除前导出
"导出今天的对话记录"

# 清除
/clear

# 需要时查阅导出的文件
```

### Q3: 清除会影响性能吗？

**回答**：正面影响！

```bash
清除的好处：
✓ 减少上下文长度
✓ 提升响应速度
✓ 降低 token 使用
✓ 减少混淆

建议：
- 对话超过 100 条时清除
- 感觉响应变慢时清除
- 切换任务时清除
```

### Q4: 如何避免频繁清除？

**策略**：
```bash
# 1. 使用记忆系统
#
"记住项目配置"  # 清除后仍保留

# 2. 文档化
重要信息写入 README、docs/

# 3. 模块化对话
专注单一任务，完成后清除

# 4. 定期清理
不要等到 200+ 消息才清
```

### Q5: /clear vs Ctrl+L 的区别？

**区别**：
```bash
/clear
- 清除对话上下文
- Claude 忘记之前的讨论
- 新的对话开始

Ctrl+L
- 只清除屏幕显示
- Claude 记得所有内容
- 继续当前对话
```

**选择**：
```bash
想要清空屏幕 → Ctrl+L
想要新的对话 → /clear
```

### Q6: 能否撤销清除操作？

**回答**：不能直接撤销，但有替代方案

```bash
# 方案 1: 使用 /resume
/resume  # 恢复到清除前的状态

# 方案 2: 重新提供上下文
"我们之前在讨论 [主题]
已经完成了 [进度]
现在继续 [下一步]"

# 方案 3: 查看导出的记录
cat conversation-export.md
```

---

## 技巧和窍门

### 技巧 1: 智能清除时机

```bash
# 创建自动提醒
# .claude/commands/check-context.md

检查是否需要清除：
- 对话消息数量
- 对话持续时间
- 主题变化次数

如果需要，建议：
1. 总结当前进度
2. 保存重要信息
3. 执行 /clear
```

### 技巧 2: 清除模板

```bash
# 创建清除工作流
# .claude/commands/clean-start.md

清除并重新开始：
1. 总结当前会话的要点
2. 保存到 SESSION_NOTES.md
3. 执行 /clear
4. 询问下一个任务
5. 提供项目上下文

# 使用：
/clean-start
```

### 技巧 3: 阶段性清除

```bash
# 在大型任务中分阶段
阶段 1: 设计 → 完成 → 总结 → /clear
阶段 2: 实现 → 完成 → 总结 → /clear
阶段 3: 测试 → 完成 → 总结 → /clear
阶段 4: 部署 → 完成 → 总结 → /clear
```

### 技巧 4: 上下文快照

```bash
# 清除前创建快照
"创建当前会话的完整快照
包括：
- 讨论的主题
- 做出的决策
- 待办事项
- 下一步计划

保存到 SNAPSHOT.md"

# 清除
/clear

# 需要时恢复
"基于 SNAPSHOT.md 的内容继续工作"
```

### 技巧 5: 清除后检查清单

```bash
# 创建清除后的例行检查
# .claude/commands/post-clear.md

清除完成，开始新会话前检查：

✓ 项目上下文
- [ ] 项目类型和技术栈
- [ ] 当前目录位置
- [ ] Git 分支状态

✓ 任务上下文
- [ ] 当前任务目标
- [ ] 相关背景信息
- [ ] 待办事项列表

✓ 记忆系统
- [ ] 检查 /memory
- [ ] 确认项目配置保留
- [ ] 确认偏好设置保留

准备就绪，开始工作！
```

### 技巧 6: 清除与 Git 配合

```bash
# 清除与 Git 工作流结合
git commit -am "完成功能 A"  # 提交代码
/clear                        # 清除上下文
git checkout -b feature-b     # 新分支
"开始新功能 B..."             # 新任务
```

### 技巧 7: 批量清除策略

```bash
# 工作日结束时
"总结今天所有工作" > daily-summary.md
/clear
git push
# 明天清新开始
```

### 技巧 8: 清除日志

```bash
# 记录清除历史
# .claude/commands/clear-log.md

记录清除操作：
- 时间戳
- 清除原因
- 任务完成情况
- 下一步计划

添加到 CLEAR_LOG.md

# 用于：
- 回顾工作模式
- 优化清除频率
- 追踪任务进度
```

---

## 🎓 学习路径

### 第 1 周：基础使用

```bash
Day 1-2: 理解 /clear
- 什么是清除
- 清除什么
- 不清除什么
- 练习：执行基本清除

Day 3-4: 清除时机
- 识别需要清除的场景
- 清除前的准备
- 清除后的恢复
- 练习：合理的清除时机

Day 5-7: 与其他功能配合
- 清除 + 记忆系统
- 清除 + /resume
- 清除 + Git
```

### 第 2 周：进阶技巧

```bash
Day 1-2: 上下文管理
- 选择性保留信息
- 快速恢复上下文
- 文档化重要信息

Day 3-4: 工作流优化
- 每日清除流程
- 任务切换流程
- 项目切换流程

Day 5-7: 自动化
- 创建清除模板
- 自动提醒机制
- 清除日志系统
```

### 第 3 周：团队实践

```bash
Day 1-2: 团队规范
- 清除规范制定
- 上下文共享
- 知识管理

Day 3-4: 最佳实践
- 大型项目中的清除
- 持续集成环境
- 文档自动化

Day 5-7: 经验总结
- 回顾清除模式
- 优化工作流程
- 分享团队经验
```

---

## 📚 相关资源

### 相关命令
- [/resume](./RESUME_COMMAND_GUIDE.md) - 恢复历史会话
- [/memory](./MEMORY_COMMAND_GUIDE.md) - 管理记忆
- [/exit](./EXIT_COMMAND_GUIDE.md) - 退出程序

### 项目内资源
- [命令学习目录](./README.md)
- [完整 Tips](../CLAUDE_CODE_TIPS.md)
- [学习计划](../guides/LEARNING_PLAN.md)

---

## ✅ 学习检查清单

```markdown
### /clear 命令掌握度

#### 基础 (必须掌握)
- [ ] 理解 /clear 的作用
- [ ] 能够执行基本清除
- [ ] 知道何时应该清除
- [ ] 知道何时不应该清除

#### 中级 (应该掌握)
- [ ] 清除前保存重要信息
- [ ] 清除后快速恢复上下文
- [ ] 配合记忆系统使用
- [ ] 配合 /resume 使用

#### 高级 (可以掌握)
- [ ] 创建清除工作流
- [ ] 优化清除频率
- [ ] 实现上下文管理策略
- [ ] 团队清除规范

#### 专家 (长期目标)
- [ ] 自动化清除流程
- [ ] 清除模式分析
- [ ] 培训团队成员
- [ ] 贡献最佳实践
```

---

<div align="center">
  <sub>🧹 保持清晰的上下文，保持高效的工作状态！</sub>
  <br>
  <sub>定期清理，事半功倍</sub>
</div>
